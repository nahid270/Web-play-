# =====================================================================================
# ||      GODFATHER MOVIE BOT (v4.7 - Pagination Update)                           ||
# ||---------------------------------------------------------------------------------||
# || ‡¶è‡¶á ‡¶∏‡¶Ç‡¶∏‡ßç‡¶ï‡¶∞‡¶£‡ßá ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™ ‡¶ì ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶≠‡ßá‡¶ü ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶§ ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶Ö‡¶ü‡ßã-‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶¨‡ßá‡•§            ||
# || ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™‡ßá ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö ‡¶ï‡¶∞‡ßá ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶®‡¶æ ‡¶™‡ßá‡¶≤‡ßá ‡¶¨‡¶ü ‡¶ö‡ßÅ‡¶™ ‡¶•‡¶æ‡¶ï‡¶¨‡ßá ‡¶è‡¶¨‡¶Ç ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶≠‡ßá‡¶ü‡ßá ‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶¶‡ßá‡¶¨‡ßá‡•§        ||
# || ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö ‡¶∞‡ßá‡¶ú‡¶æ‡¶≤‡ßç‡¶ü‡ßá ‡¶™‡ßá‡¶ú‡¶ø‡¶®‡ßá‡¶∂‡¶® (‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞) ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§                         ||
# =====================================================================================

import os
import re
import math
import base64
import logging
import asyncio
from dotenv import load_dotenv
from threading import Thread
from flask import Flask
from pyrogram import Client, filters
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.enums import ChatType
from pyrogram.errors import MessageNotModified
from motor.motor_asyncio import AsyncIOMotorClient
from bson.objectid import ObjectId

# --- ‡¶™‡¶∞‡¶ø‡¶¨‡ßá‡¶∂ ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ ‡¶ì ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶® ---
load_dotenv()
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
LOGGER = logging.getLogger(__name__)

# --- ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶´‡¶æ‡¶á‡¶≤ ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤‡ßá‡¶∞ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡¶ø‡¶® ---
FILE_CHANNEL_ID = -1002744890741  # <====== ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ü‡¶∏‡¶≤ ‡¶´‡¶æ‡¶á‡¶≤ ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤‡ßá‡¶∞ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡¶ø‡¶®
if FILE_CHANNEL_ID == 0:
    LOGGER.critical("CRITICAL: Please update the FILE_CHANNEL_ID in the code.")
    exit()

try:
    API_ID = int(os.environ.get("API_ID"))
    API_HASH = os.environ.get("API_HASH")
    BOT_TOKEN = os.environ.get("BOT_TOKEN")
    MONGO_URL = os.environ.get("MONGO_URL")
    AD_PAGE_URL = os.environ.get("AD_PAGE_URL")
    ADMIN_IDS = [int(id.strip()) for id in os.environ.get("ADMIN_IDS", "").split(',') if id.strip()]
    PORT = int(os.environ.get("PORT", 8080))
    DELETE_DELAY = 15 * 60  # 15 ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü
    SEARCH_PAGE_SIZE = 8 # <--- ‡¶®‡¶§‡ßÅ‡¶® ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ú‡¶®: ‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡ßü ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶∞‡ßá‡¶ú‡¶æ‡¶≤‡ßç‡¶ü‡ßá‡¶∞ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ
except (ValueError, TypeError) as e:
    LOGGER.critical(f"Configuration error in environment variables: {e}")
    exit()

# --- ‡¶ï‡ßç‡¶≤‡¶æ‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü, ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶ì ‡¶ì‡ßü‡ßá‡¶¨ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ ---
app = Client("MovieBot", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN)
mongo_client = AsyncIOMotorClient(MONGO_URL)
db = mongo_client["MovieDB"]
movie_info_db = db["movie_info"]
files_db = db["files"]
users_db = db["users"]
web_app = Flask(__name__)
@web_app.route('/')
def health_check(): return "Bot is alive and running!"

# ========= üìÑ ‡¶π‡ßá‡¶≤‡ßç‡¶™‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ========= #
def is_admin(_, __, message):
    """‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶°‡¶ü‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® ‡¶™‡¶æ‡¶†‡¶ø‡ßü‡ßá‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡¶æ ‡¶§‡¶æ ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßá"""
    return message.from_user and message.from_user.id in ADMIN_IDS

admin_filter = filters.create(is_admin)

async def delete_messages_after_delay(messages_to_delete, delay):
    """‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü ‡¶∏‡¶Æ‡ßü ‡¶™‡¶∞ ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ü‡¶æ‡¶∏‡ßç‡¶ï ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá"""
    await asyncio.sleep(delay)
    for msg in messages_to_delete:
        try:
            if msg: await msg.delete()
        except Exception:
            pass

# ========= üì¢ ‡¶®‡¶Æ‡¶®‡ßÄ‡¶Ø‡¶º ‡¶á‡¶®‡¶°‡ßá‡¶ï‡ßç‡¶∏‡¶ø‡¶Ç ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞ ========= #
@app.on_message(filters.channel & (filters.video | filters.document))
async def flexible_save_movie_quality(client, message):
    if message.chat.id != FILE_CHANNEL_ID: return
    caption = message.caption or ""
    # ‡¶∂‡¶ø‡¶∞‡ßã‡¶®‡¶æ‡¶Æ ‡¶è‡¶¨‡¶Ç ‡¶¨‡¶õ‡¶∞ ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ
    title_match = re.search(r"(.+?)\s*\(?(\d{4})\)?", caption, re.IGNORECASE)
    year = None
    if title_match:
        raw_title = title_match.group(1).strip()
        year = title_match.group(2)
    else: # ‡¶Ø‡¶¶‡¶ø ‡¶¨‡¶õ‡¶∞ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶®‡¶æ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü, ‡¶§‡¶¨‡ßá ‡¶∏‡ßç‡¶ü‡¶™-‡¶ì‡ßü‡¶æ‡¶∞‡ßç‡¶° ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶∂‡¶ø‡¶∞‡ßã‡¶®‡¶æ‡¶Æ ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ
        stop_words = ['480p', '720p', '1080p', '2160p', '4k', 'hindi', 'english', 'bangla', 'bengali', 'dual', 'audio', 'web-dl', 'hdrip', 'bluray', 'webrip']
        title_words = []
        for word in caption.split():
            if any(stop in word.lower() for stop in stop_words): break
            title_words.append(word)
        raw_title = ' '.join(title_words).strip()

    if not raw_title:
        LOGGER.warning(f"Could not parse a valid title from caption: '{caption}'"); return

    clean_title = re.sub(r'[\.\_]', ' ', raw_title).strip()
    quality = next((q for q in ["480p", "720p", "1080p", "2160p", "4k"] if q in caption.lower()), "Unknown")
    languages_to_check = ["hindi", "bangla", "bengali", "english", "tamil", "telugu", "malayalam", "kannada"]
    caption_lower = caption.lower()
    language = "Unknown"
    for lang in languages_to_check:
        if lang in caption_lower:
            language = "Bangla" if lang in ["bangla", "bengali"] else lang.capitalize()
            break
    
    query = {"title_lower": clean_title.lower()}
    if year: query["year"] = year
    movie_doc = await movie_info_db.find_one_and_update(query, {"$setOnInsert": {"title": clean_title, "year": year, "title_lower": clean_title.lower()}}, upsert=True, return_document=True)
    
    file_info = message.video or message.document
    await files_db.update_one({"movie_id": movie_doc['_id'], "quality": quality, "language": language}, {"$set": {"file_id": file_info.file_id, "chat_id": message.chat.id, "msg_id": message.id}}, upsert=True)
    
    log_year = f"({year})" if year else "(No Year)"
    LOGGER.info(f"‚úÖ Indexed: {clean_title} {log_year} [{quality} - {language}]")

# ========= üëÆ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ========= #
@app.on_message(filters.command("stats") & admin_filter)
async def stats_command(client, message):
    total_users, total_movies, total_files = await asyncio.gather(users_db.count_documents({}), movie_info_db.count_documents({}), files_db.count_documents({}))
    await message.reply_text(f"üìä **Bot Stats**\n\nüë• Users: `{total_users}`\nüé¨ Movies: `{total_movies}`\nüìÅ Files: `{total_files}`\n\nüì¢ **Indexing Channel:** `{FILE_CHANNEL_ID}`")

# ========= ü§ñ ‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶ü ‡¶è‡¶¨‡¶Ç ‡¶ï‡¶≤‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞ ========= #
@app.on_message(filters.private & filters.command("start"))
async def start_handler(client, message):
    user_id = message.from_user.id
    await users_db.update_one({"_id": user_id}, {"$set": {"name": message.from_user.first_name}}, upsert=True)
    
    if len(message.command) > 1:
        try:
            payload = message.command[1]
            decoded_data = base64.urlsafe_b64decode(payload).decode()
            parts = decoded_data.split('_')
            if len(parts) != 3: raise ValueError("Invalid payload format")
            
            action, data_id, verified_user_id_str = parts
            if user_id != int(verified_user_id_str):
                return await message.reply_text("üò° ‡¶è‡¶á ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶ü‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶®‡ßü‡•§")

            if action == "file":
                file_doc = await files_db.find_one({"_id": ObjectId(data_id)})
                if file_doc:
                    movie_doc = await movie_info_db.find_one({"_id": file_doc['movie_id']})
                    display_year = f"({movie_doc['year']})" if movie_doc.get('year') else ""
                    final_caption = (f"üé¨ **{movie_doc['title']} {display_year}**\n"
                                     f"‚ú® **Quality:** {file_doc['quality']}\n"
                                     f"üåê **Language:** {file_doc['language']}\n\n"
                                     f"üôè Thank you for using our bot!")
                    
                    movie_msg = await client.copy_message(chat_id=user_id, from_chat_id=file_doc['chat_id'], message_id=file_doc['msg_id'], caption=final_caption)
                    warning_msg = await message.reply_text(f"‚ùó ‡¶´‡¶æ‡¶á‡¶≤‡¶ü‡¶ø **{DELETE_DELAY // 60} ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü** ‡¶™‡¶∞ ‡¶Ö‡¶ü‡ßã-‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶π‡ßü‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡•§", quote=True)
                    asyncio.create_task(delete_messages_after_delay([movie_msg, warning_msg], DELETE_DELAY))
        except Exception as e:
            LOGGER.error(f"Deep link error: {e}")
            await message.reply_text("ü§î ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Æ‡ßç‡¶≠‡¶¨‡¶§ inv√°lid ‡¶¨‡¶æ ‡¶Æ‡ßá‡ßü‡¶æ‡¶¶‡ßã‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£‡•§")
    else:
        reply_msg = await message.reply_text(f"üëã Hello, **{message.from_user.first_name}**!\nSend me a movie or series name to search.")
        asyncio.create_task(delete_messages_after_delay([message, reply_msg], 120))

# <--- ‡¶®‡¶§‡ßÅ‡¶® ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ú‡¶®: ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö ‡¶∞‡ßá‡¶ú‡¶æ‡¶≤‡ßç‡¶ü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡ßá‡¶ú‡¶ø‡¶®‡ßá‡¶∂‡¶® ‡¶¨‡¶æ‡¶ü‡¶® ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® --->
def build_search_results_markup(results, query, current_page, total_count):
    """‡¶∏‡¶æ‡¶∞‡ßç‡¶ö ‡¶∞‡ßá‡¶ú‡¶æ‡¶≤‡ßç‡¶ü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶á‡¶®‡¶≤‡¶æ‡¶á‡¶® ‡¶ï‡¶ø‡¶¨‡ßã‡¶∞‡ßç‡¶° ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ï‡¶Ü‡¶™ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá, ‡¶™‡ßá‡¶ú‡¶ø‡¶®‡ßá‡¶∂‡¶® ‡¶∏‡¶π‡•§"""
    buttons = []
    for movie in results:
        display_year = f"({movie['year']})" if movie.get('year') else ""
        buttons.append([InlineKeyboardButton(f"üé¨ {movie['title']} {display_year}", callback_data=f"showqual_{movie['_id']}")])
    
    # ‡¶™‡ßá‡¶ú‡¶ø‡¶®‡ßá‡¶∂‡¶® ‡¶¨‡¶æ‡¶ü‡¶® ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ
    if total_count > SEARCH_PAGE_SIZE:
        nav_buttons = []
        total_pages = math.ceil(total_count / SEARCH_PAGE_SIZE)
        
        if current_page > 0:
            nav_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è ‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶™‡¶æ‡¶§‡¶æ", callback_data=f"nav_{current_page-1}_{query}"))
        
        nav_buttons.append(InlineKeyboardButton(f"üìÑ {current_page+1}/{total_pages} üìÑ", callback_data="noop")) # No operation button

        if (current_page + 1) * SEARCH_PAGE_SIZE < total_count:
            nav_buttons.append(InlineKeyboardButton("‡¶™‡¶∞‡ßá‡¶∞ ‡¶™‡¶æ‡¶§‡¶æ ‚û°Ô∏è", callback_data=f"nav_{current_page+1}_{query}"))
        
        buttons.append(nav_buttons)
        
    return InlineKeyboardMarkup(buttons)

@app.on_callback_query()
async def callback_handler(client, callback_query):
    data, user_id = callback_query.data, callback_query.from_user.id
    
    if data == "noop": # ‡¶®‡¶§‡ßÅ‡¶® ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ú‡¶®: ‡¶™‡ßá‡¶ú ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶¨‡¶æ‡¶ü‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
        await callback_query.answer()
        return

    if data.startswith("showqual_"):
        movie_id = ObjectId(data.split("_", 1)[1])
        new_msg = await show_quality_options(callback_query.message, movie_id, is_edit=True, return_message=True)
        if new_msg:
            asyncio.create_task(delete_messages_after_delay([new_msg], DELETE_DELAY))

    elif data.startswith("getfile_"):
        file_id_str = data.split("_", 1)[1]
        encoded_data = base64.urlsafe_b64encode(f'file_{file_id_str}_{user_id}'.encode()).decode()
        verification_url = f"{AD_PAGE_URL}?data={encoded_data}"
        await callback_query.message.edit_reply_markup(InlineKeyboardMarkup([[InlineKeyboardButton("‚úÖ ‡¶≠‡ßá‡¶∞‡¶ø‡¶´‡¶æ‡¶á ‡¶ï‡¶∞‡ßá ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡ßÅ‡¶®", url=verification_url)]]))
    
    # <--- ‡¶®‡¶§‡ßÅ‡¶® ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ú‡¶®: ‡¶™‡ßá‡¶ú‡¶ø‡¶®‡ßá‡¶∂‡¶® ‡¶®‡ßá‡¶≠‡¶ø‡¶ó‡ßá‡¶∂‡¶® ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡ßá‡¶≤ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø --->
    elif data.startswith("nav_"):
        try:
            _, page_str, query = data.split("_", 2)
            current_page = int(page_str)
            
            search_pattern = '.*'.join(query.split())
            search_regex = re.compile(search_pattern, re.IGNORECASE)

            total_count = await movie_info_db.count_documents({'title_lower': search_regex})
            results = await movie_info_db.find({'title_lower': search_regex}).skip(current_page * SEARCH_PAGE_SIZE).limit(SEARCH_PAGE_SIZE).to_list(length=SEARCH_PAGE_SIZE)
            
            if results:
                markup = build_search_results_markup(results, query, current_page, total_count)
                await callback_query.message.edit_text("ü§î ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶è‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ñ‡ßÅ‡¶Å‡¶ú‡¶õ‡ßá‡¶®?", reply_markup=markup)

        except MessageNotModified:
            pass # ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶è‡¶ï‡¶á ‡¶™‡ßá‡¶ú ‡¶¨‡¶æ‡¶ü‡¶®‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡¶≤‡ßá ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶®‡ßá‡¶á
        except Exception as e:
            LOGGER.error(f"Navigation callback error: {e}")
            await callback_query.answer("‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶è‡¶ï‡¶ü‡¶æ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§", show_alert=True)

    await callback_query.answer()

async def show_quality_options(message, movie_id, is_edit=False, return_message=False):
    reply_msg = None
    try:
        files = await files_db.find({"movie_id": movie_id}).sort("quality").to_list(length=None)
        if not files:
            text = "‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶è‡¶á ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ï‡ßã‡¶®‡ßã ‡¶´‡¶æ‡¶á‡¶≤ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§"
            reply_msg = await message.edit_text(text) if is_edit else await message.reply_text(text)
            return reply_msg if return_message else None

        movie = await movie_info_db.find_one({"_id": movie_id})
        if not movie:
            text = "‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶∞ ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶§‡¶•‡ßç‡¶Ø ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§"
            reply_msg = await message.edit_text(text) if is_edit else await message.reply_text(text)
            return reply_msg if return_message else None

        display_year = f"({movie['year']})" if movie.get('year') else ""
        text = f"üé¨ **{movie['title']} {display_year}**\n\nüëá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡¶õ‡¶®‡ßç‡¶¶‡ßá‡¶∞ ‡¶ï‡ßã‡ßü‡¶æ‡¶≤‡¶ø‡¶ü‡¶ø ‡¶¨‡ßá‡¶õ‡ßá ‡¶®‡¶ø‡¶®:"
        buttons = [[InlineKeyboardButton(f"‚ú® {f['quality']} | üåê {f['language']}", callback_data=f"getfile_{f['_id']}")] for f in files]
        
        markup = InlineKeyboardMarkup(buttons)
        if is_edit:
            await message.edit_text(text, reply_markup=markup)
            reply_msg = message
        else:
            reply_msg = await message.reply_text(text, reply_markup=markup, quote=True)
        
        return reply_msg if return_message else None

    except MessageNotModified: return message if return_message else None
    except Exception as e: LOGGER.error(f"Show quality options error: {e}"); return None

# ========= üîé ‡¶ö‡ßÇ‡ßú‡¶æ‡¶®‡ßç‡¶§ Regex ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞ (‡¶ó‡ßç‡¶∞‡ßÅ‡¶™‡ßá ‡¶∏‡¶æ‡¶á‡¶≤‡ßá‡¶®‡ßç‡¶ü, ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶≠‡ßá‡¶ü‡ßá ‡¶∞‡ßá‡¶∏‡¶™‡¶®‡ßç‡¶∏‡¶ø‡¶≠) ========= #
@app.on_message((filters.private | filters.group) & filters.text)
async def reliable_search_handler(client, message):
    if message.text and message.text.startswith('/'): return
    if message.from_user.is_bot: return

    query = message.text.strip()
    cleaned_query = ' '.join(re.findall(r'\b[a-zA-Z0-9]+\b', query.lower()))
    if not cleaned_query: return
    
    search_pattern = '.*'.join(cleaned_query.split())
    search_regex = re.compile(search_pattern, re.IGNORECASE)
    
    messages_to_delete = [message]
    reply_msg = None

    try:
        # <--- ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®: ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶Æ‡ßã‡¶ü ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ó‡¶£‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá, ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∞‡ßá‡¶ú‡¶æ‡¶≤‡ßç‡¶ü ‡¶Ü‡¶®‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá --->
        total_count = await movie_info_db.count_documents({'title_lower': search_regex})
        LOGGER.info(f"Search for '{cleaned_query}' in chat {message.chat.id} ({message.chat.type.name}) found {total_count} total results.")
        
        if total_count == 0:
            if message.chat.type == ChatType.PRIVATE:
                reply_msg = await message.reply_text("‚ùå **‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶ü‡¶ø ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø!**\n\n‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ‡¶Æ‡ßá‡¶∞ ‡¶¨‡¶æ‡¶®‡¶æ‡¶®‡¶ü‡¶ø ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§", quote=True)
                messages_to_delete.append(reply_msg)
            # ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶¶‡ßá‡¶ì‡ßü‡¶æ ‡¶π‡¶¨‡ßá ‡¶®‡¶æ
            
        elif total_count == 1:
            movie = await movie_info_db.find_one({'title_lower': search_regex})
            reply_msg = await show_quality_options(message, movie['_id'], return_message=True)
            if reply_msg: messages_to_delete.append(reply_msg)
        else:
            # ‡¶™‡ßá‡¶ú 0 (‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶™‡¶æ‡¶§‡¶æ) ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∞‡ßá‡¶ú‡¶æ‡¶≤‡ßç‡¶ü ‡¶Ü‡¶®‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá
            results = await movie_info_db.find({'title_lower': search_regex}).limit(SEARCH_PAGE_SIZE).to_list(length=SEARCH_PAGE_SIZE)
            markup = build_search_results_markup(results, cleaned_query, 0, total_count)
            reply_msg = await message.reply_text("ü§î ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶è‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ñ‡ßÅ‡¶Å‡¶ú‡¶õ‡ßá‡¶®?", reply_markup=markup, quote=True)
            messages_to_delete.append(reply_msg)

    except Exception as e:
        LOGGER.error(f"Database search error: {e}")
        if message.chat.type == ChatType.PRIVATE:
            reply_msg = await message.reply_text("‚ö†Ô∏è ‡¶¨‡¶ü ‡¶è‡¶ï‡¶ü‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶∏‡¶Æ‡ßç‡¶Æ‡ßÅ‡¶ñ‡ßÄ‡¶® ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
            messages_to_delete.append(reply_msg)
        # ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶¶‡ßá‡¶ì‡ßü‡¶æ ‡¶π‡¶¨‡ßá ‡¶®‡¶æ
    
    finally:
        if messages_to_delete:
            asyncio.create_task(delete_messages_after_delay(messages_to_delete, DELETE_DELAY))

# ========= ‚ñ∂Ô∏è ‡¶¨‡¶ü ‡¶è‡¶¨‡¶Ç ‡¶ì‡ßü‡ßá‡¶¨ ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡¶æ ========= #
def run_web_server():
    web_app.run(host='0.0.0.0', port=PORT)

if __name__ == "__main__":
    LOGGER.info("Starting web server on a separate thread...")
    web_thread = Thread(target=run_web_server)
    web_thread.start()
    
    LOGGER.info("The Don is waking up... (v4.7 Pagination Update)")
    app.run()
    LOGGER.info("The Don is resting...")
